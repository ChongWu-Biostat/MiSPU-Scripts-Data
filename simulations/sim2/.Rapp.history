sum(minp <minp.dist)
(sum(minp <minp.dist)+1)/n.perm
library(MASS)#
library("truncnorm")#
library(lme4)#
library(lmerTest)#
###############################################################################
### Get the core index, we will use this index as the lambda2 index      ######
###############################################################################
args=(commandArgs(TRUE))#
job = as.numeric(gsub("\\job=", "", args))#
data.index = job#
chip.size = 10#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
beta = c(rep(0.01,1),rep(0,n.y-1))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.5),(tmp.norm.ind<0.3)* rnorm(n,0.3,0.2)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.7,0.2))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.01#
sigma.e = 0.01#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
max(error)#
min(error)#
#
Y <- as.matrix(beta) %*% t(as.matrix(Z)) + error#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")
beta <- Y#
    beta = t(beta)#
    is.X.null = is.null(X)#
    if( is.X.null) {#
        beta1 =as.data.frame(beta)#
        beta1$chip = rep(1:length(C),each = C[1])#
        beta1$Z = Z#
    } else {#
        X = as.data.frame(X)#
        X$chip = rep(1:length(C),each = C[1])#
        X$Z = Z#
        beta1 = as.data.frame(cbind(beta,X))#
    }#
    site.list = colnames(beta)#
    n = dim(Y)[2]
is.X.null
formula = as.formula(paste(x,"~(1|chip)+Z + X1 + X2", sep=""))#
            model =try (do.call("lmer", args = list(formula,data=beta1,na.action="na.exclude")))
beta <- Y#
    beta = t(beta)#
    is.X.null = is.null(X)#
    if( is.X.null) {#
        beta1 =as.data.frame(beta)#
        beta1$chip = rep(1:length(C),each = C[1])#
        beta1$Z = Z#
    } else {#
        X = as.data.frame(X)#
        X$chip = rep(1:length(C),each = C[1])#
        X$Z = Z#
        beta1 = as.data.frame(cbind(beta,X))#
    }#
    site.list = colnames(beta)#
    n = dim(Y)[2]#
    mix_eff_p=lapply(site.list, function(x)     #mixed models#
    {#
        if(is.X.null) {#
            formula = as.formula(paste(x,"~(1|chip)+Z", sep=""))#
            model =try (do.call("lmer", args = list(formula,data=beta1,na.action="na.exclude")))#
            res = anova(model)[1,6]#
        } else {#
            formula = as.formula(paste(x,"~(1|chip)+Z + X1 + X2", sep=""))#
            model =try (do.call("lmer", args = list(formula,data=beta1,na.action="na.exclude")))#
        }#
    }#
    ) ## calcluate the Sigma_k in the LMM, we will use it in the future. The main difference between SKAT and this
x = site.list[1]
formula = as.formula(paste(x,"~(1|chip)+Z + X1 + X2", sep=""))#
            model =try (do.call("lmer", args = list(formula,data=beta1,na.action="na.exclude")))
model =try (do.call("lmer", args = list(formula,data=beta1,na.action="na.exclude")))
beta1
rownames(Y) = paste("Y",c(1:n.y),sep="")
beta <- Y#
    beta = t(beta)#
    is.X.null = is.null(X)#
    if( is.X.null) {#
        beta1 =as.data.frame(beta)#
        beta1$chip = rep(1:length(C),each = C[1])#
        beta1$Z = Z#
    } else {#
        X = as.data.frame(X)#
        X$chip = rep(1:length(C),each = C[1])#
        X$Z = Z#
        beta1 = as.data.frame(cbind(beta,X))#
    }#
    site.list = colnames(beta)#
    n = dim(Y)[2]
formula = as.formula(paste(x,"~(1|chip)+Z + X1 + X2", sep=""))#
            model =try (do.call("lmer", args = list(formula,data=beta1,na.action="na.exclude")))
x
x = site.list[1]
x
formula = as.formula(paste(x,"~(1|chip)+Z + X1 + X2", sep=""))#
            model =try (do.call("lmer", args = list(formula,data=beta1,na.action="na.exclude")))
anova(model)
anova(model)[1,6]
library(MASS)#
library(gdata)#
library(mixtools)#
n=100    #100 observatios on each site#
k=20     #20 sites#
x=rbinom(n,1,0.3)    #smoking status 0 or 1#
Sig=matrix(c(rep(0.01,n*n)),n,n)    #
diag(Sig)=c(rep(0.02,n))
Sig
install.packages(mixtools)
install.packages("mixtools")
library(MASS)#
library(gdata)#
library(mixtools)#
n=100    #100 observatios on each site#
k=20     #20 sites#
x=rbinom(n,1,0.3)    #smoking status 0 or 1#
Sig=matrix(c(rep(0.01,n*n)),n,n)    #
diag(Sig)=c(rep(0.02,n))#
Sinv=solve(Sig)#
lambda=rep(1, 2)/2#
mu=c(0.1, 0.6)#
sigma=rep(0.01, 2)#
beta_0=rnormmix(k,lambda,mu,sigma)   #mean methylations are mixture normal#
beta_1=c(rep(0.05,1),rep(0,19))   #5% #change here to get 10%, 20% etc #
#beta_1=c(rep(0.05,2),rep(0,18))      #  this is for 10%    etc.                                  #
o=rep(1,n)#
a1=t(o)%*%Sinv%*%x#
b1=sum(Sinv)#
mean=matrix(0,n,k)#
for ( i in 1:k)#
{#
mean[,i]=beta_0[i]+beta_1[i]*x#
}
mean
U={}#
Y=matrix(0,n,k)
k
Y
for ( i in 1:k)#
{#
Y[,i]=mvrnorm(1,mean[,i],Sig)#
U[i]=t(Y[,i])%*%Sinv%*%x-t(Y[,i])%*%Sinv%*%o*a1/b1#
}#
T=t(U)%*%U       #Test statistic
T
U
Sig
library(MASS)#
library("truncnorm")#
library(lme4)#
library(lmerTest)#
###############################################################################
### Get the core index, we will use this index as the lambda2 index      ######
###############################################################################
args=(commandArgs(TRUE))#
job = as.numeric(gsub("\\job=", "", args))#
data.index = job#
chip.size = 10#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
beta = c(rep(0.01,1),rep(0,n.y-1))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.5),(tmp.norm.ind<0.3)* rnorm(n,0.3,0.2)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.7,0.2))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.01#
sigma.e = 0.01#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
max(error)#
min(error)
library(MASS)#
library("truncnorm")#
library(lme4)#
library(lmerTest)#
###############################################################################
### Get the core index, we will use this index as the lambda2 index      ######
###############################################################################
args=(commandArgs(TRUE))#
job = as.numeric(gsub("\\job=", "", args))#
data.index = job#
chip.size = 10#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
beta = c(rep(0.01,1),rep(0,n.y-1))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.5),(tmp.norm.ind<0.3)* rnorm(n,0.3,0.2)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.7,0.2))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.005#
sigma.e = 0.005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
max(error)#
min(error)
library(MASS)#
library("truncnorm")#
library(lme4)#
library(lmerTest)#
###############################################################################
### Get the core index, we will use this index as the lambda2 index      ######
###############################################################################
args=(commandArgs(TRUE))#
job = as.numeric(gsub("\\job=", "", args))#
data.index = job#
chip.size = 10#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
beta = c(rep(0.01,1),rep(0,n.y-1))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.5),(tmp.norm.ind<0.3)* rnorm(n,0.3,0.2)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.7,0.2))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.001#
sigma.e = 0.001#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
max(error)#
min(error)
sqrt(0.02)
?mvrnorm
sqrt(0.01)
0.01^2
##################################
#
library(MASS)#
library("truncnorm")#
library(lme4)#
library(lmerTest)#
###############################################################################
### Get the core index, we will use this index as the lambda2 index      ######
###############################################################################
args=(commandArgs(TRUE))#
job = as.numeric(gsub("\\job=", "", args))#
data.index = job#
chip.size = 10#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
beta = c(rep(0.01,1),rep(0,n.y-1))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.5),(tmp.norm.ind<0.3)* rnorm(n,0.3,0.2)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.7,0.2))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
max(error)#
min(error)
library(MASS)#
library("truncnorm")#
library(lme4)#
library(lmerTest)#
###############################################################################
### Get the core index, we will use this index as the lambda2 index      ######
###############################################################################
args=(commandArgs(TRUE))#
job = as.numeric(gsub("\\job=", "", args))#
data.index = job#
chip.size = 10#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
beta = c(rep(0.01,1),rep(0,n.y-1))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.5),(tmp.norm.ind<0.3)* rnorm(n,0.3,0.2)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.7,0.2))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
max(error)#
min(error)#
#
Y <- as.matrix(beta) %*% t(as.matrix(Z)) + error#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")#
rownames(Y) = paste("Y",c(1:n.y),sep="")#
SumSqU(Y,X,Z,C)
SumSqU <- function(Y, X, Z,C) {#
    beta <- Y#
    beta = t(beta)#
    is.X.null = is.null(X)#
    if( is.X.null) {#
        beta1 =as.data.frame(beta)#
        beta1$chip = rep(1:length(C),each = C[1])#
        beta1$Z = Z#
    } else {#
        X = as.data.frame(X)#
        X$chip = rep(1:length(C),each = C[1])#
        X$Z = Z#
        beta1 = as.data.frame(cbind(beta,X))#
    }#
    site.list = colnames(beta)#
    n = dim(Y)[2]#
    mix_eff_cov=lapply(site.list, function(x)     #mixed models#
    {#
        if(is.X.null) {#
            formula = as.formula(paste(x,"~(1|chip)+Z", sep=""))#
        } else {#
            formula = as.formula(paste(x,"~(1|chip)+Z + X1 + X2", sep=""))#
        }#
        model =try (do.call("lmer", args = list(formula,data=beta1,na.action="na.exclude")))#
        if (inherits(model, "try-error"))#
        c("NA")#
        else#
        {#
            v_a=as.data.frame(VarCorr(model))[1,4]        #var of batch eff#
            v_e=as.data.frame(VarCorr(model))[2,4]      #var of error#
            Cov=matrix(0,n,n)                        #list for block diagonal matrix#
            tmp.D.index1 = 1#
            for ( i in 1:length(C))#
            {#
                tmp.D.index2 = tmp.D.index1 + C[i]-1#
            Cov[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]=solve(matrix(rep(v_a,C[i]*C[i]),C[i],C[i]) + diag(v_e,C[i]))# matrix(rep(v_a,C[i]*C[i]),C[i],C[i]) + diag(v_e,C[i]) ##
                tmp.D.index1 = tmp.D.index2 + 1#
            }#
            return(Cov)#
        }#
    }#
    ) ## calcluate the Sigma_k in the LMM, we will use it in the future. The main difference between SKAT and this method#
    names(mix_eff_cov)=site.list#
    tilde.x = cbind(rep(1,n), beta1$X1,beta1$X2)#
    score_stat=lapply(site.list, function(x)     #score stats for m sites#
    {#
        hat.beta = (solve(t(tilde.x) %*% mix_eff_cov[[x]] %*% tilde.x)) %*% (t(tilde.x) %*% mix_eff_cov[[x]] %*%as.matrix(beta1[x]))#
        s=t(beta1[x])%*%mix_eff_cov[[x]] %*% beta1$Z-t(hat.beta) %*% t(tilde.x) %*% mix_eff_cov[[x]] %*% beta1$Z#
    }#
    )#
    U=as.vector(unlist(score_stat))#
    if(sum(is.na(U)) >0) {#
        indicator =  !is.na(U)#
        site.list = site.list[indicator]#
        mix_eff_cov = mix_eff_cov[indicator]#
        U = U[indicator]#
        fianl.indicator = 9#
    } else {#
        fianl.indicator = 1#
    }# delete the NA CpG sits#
    m=length(site.list)#
    T=t(U)%*%U                                    #SumSqU test statistic#
    CovS=matrix(0,m,m)                        #cov of the m score stats#
    tmp =list()#
    sigma = list()#
    tmp.x = list()#
    for(i in 1:m) {#
        tmp[[i]] =  beta1$Z %*% mix_eff_cov[[i]] %*%tilde.x %*% (solve(t(tilde.x) %*% mix_eff_cov[[i]] %*% tilde.x))#
        sigma[[i]] = beta1$Z %*% mix_eff_cov[[i]]#
        tmp.x[[i]] = t(tilde.x) %*% mix_eff_cov[[i]]#
    }#
    for ( i in 1:m)#
    {#
        for ( j in 1:i)#
        {#
            CovS[i,j]=CovS[j,i]= cov(beta1[site.list[i]],beta1[site.list[j]]) * (sigma[[i]] %*% t(sigma[[j]]) - tmp[[i]] %*% tmp.x[[i]] %*% t(sigma[[j]]) - tmp[[j]] %*% tmp.x[[j]] %*% t(sigma[[i]]) +  tmp[[i]] %*% tmp.x[[i]] %*% t(tmp.x[[j]]) %*% t(tmp[[j]]) )#
        }#
    }#
    c=eigen(CovS,only.values=TRUE)$values        #chi_sq distrbn#
    a=Re(sum(c^3)/sum(c^2))#
    b=Re(sum(c)-(sum(c^2)^2)/(sum(c^3)))#
    d=Re((sum(c^2)^3)/(sum(c^3)^2))#
    pSumSqU=(1-pchisq((T-b)/a,d))#
    out.put = matrix(NA,1,2)#
    colnames(out.put) = c("pvalue","indicator")#
    out.put[1,] = c(pSumSqU, fianl.indicator)#
    out.put#
}
SumSqU(Y,X,Z,C)
###############################################################################
### Get the core index, we will use this index as the lambda2 index      ######
###############################################################################
args=(commandArgs(TRUE))#
job = as.numeric(gsub("\\job=", "", args))#
data.index = job#
chip.size = 10#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
beta = c(rep(0,1),rep(0,n.y-1))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.5),(tmp.norm.ind<0.3)* rnorm(n,0.3,0.2)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.7,0.2))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
max(error)#
min(error)#
#
Y <- as.matrix(beta) %*% t(as.matrix(Z)) + error#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")#
rownames(Y) = paste("Y",c(1:n.y),sep="")#
SumSqU(Y,X,Z,C)
SumSqU2 <- function(Y, X, Z,C) {#
    beta <- Y#
    beta = t(beta)#
    is.X.null = is.null(X)#
    if( is.X.null) {#
        beta1 =as.data.frame(beta)#
        beta1$chip = rep(1:length(C),each = C[1])#
        beta1$Z = Z#
    } else {#
        X = as.data.frame(X)#
        X$chip = rep(1:length(C),each = C[1])#
        X$Z = Z#
        beta1 = as.data.frame(cbind(beta,X))#
    }#
    site.list = colnames(beta)#
    n = dim(Y)[2]#
    sigsq=lapply(site.list, function(x)#
    {#
        c(var(beta1[x]))#
    }#
    ) # variance of methylation value for each site#
    names(sigsq)=site.list#
    X1 = X#
    X=Z#
    if( is.X.null) {#
        Y=cbind(rep(1,n))#
    } else {#
        Y=cbind(rep(1,n),X1) # other covariates including the intercept#
    }#
    H=Y%*%solve(t(Y)%*%Y)%*%t(Y)#
    n1=dim(H)[1]#
    I=diag(rep(1,n1))#
    IH=I-H#
    stat_t=lapply(site.list, function(x)#
    {#
        t(as.matrix(Z))%*%IH%*%as.matrix(beta1[x])/(sigsq[[x]])#
    }#
    )#
    T=as.vector(unlist(stat_t))#
    if(sum(is.na(T)) >0) {#
        indicator =  !is.na(T)#
        site.list = site.list[indicator]#
        sigsq=as.vector(unlist(sigsq))#
        sigsq = sigsq[indicator]#
        T = T[indicator]#
        beta2 = beta2[indicator,]#
        beta2 = beta2[,indicator]#
        fianl.indicator = 9#
    } else {#
        fianl.indicator = 1#
        sigsq=as.vector(unlist(sigsq))#
    }# delete the NA CpG sits#
    test_stat=t(T)%*%T#
    T=test_stat#
    m=length(site.list)#
    tau_sq=t(X)%*%IH%*%X#
    Delta_2=diag(c(1/(sigsq^2)))#
    Cov=c(tau_sq)*Delta_2%*%as.matrix(cov(beta2))#
    c=eigen(Cov,only.values=TRUE)$values        #chi_sq distrbn#
    a=Re(sum(c^3)/sum(c^2))#
    b=Re(sum(c)-(sum(c^2)^2)/(sum(c^3)))#
    d=Re((sum(c^2)^3)/(sum(c^3)^2))#
    pSumSqU=(1-pchisq((T-b)/a,d))#
    out.put = matrix(NA,1,2)#
    colnames(out.put) = c("pvalue","indicator")#
    out.put[1,] = c(pSumSqU,fianl.indicator)#
    out#
}
SumSqU2(Y,X,Z,C)
Y
beta <- Y#
    beta = t(beta)#
    is.X.null = is.null(X)#
    if( is.X.null) {#
        beta1 =as.data.frame(beta)#
        beta1$chip = rep(1:length(C),each = C[1])#
        beta1$Z = Z#
    } else {#
        X = as.data.frame(X)#
        X$chip = rep(1:length(C),each = C[1])#
        X$Z = Z#
        beta1 = as.data.frame(cbind(beta,X))#
    }#
    site.list = colnames(beta)#
    n = dim(Y)[2]#
    sigsq=lapply(site.list, function(x)#
    {#
        c(var(beta1[x]))#
    }#
    ) # variance of methylation value for each site#
    names(sigsq)=site.list#
    X1 = X#
    X=Z#
    if( is.X.null) {#
        Y=cbind(rep(1,n))#
    } else {#
        Y=cbind(rep(1,n),X1) # other covariates including the intercept#
    }
H=Y%*%solve(t(Y)%*%Y)%*%t(Y)#
    n1=dim(H)[1]#
    I=diag(rep(1,n1))#
    IH=I-H
solve(t(Y)%*%Y)
t(Y)%*%Y
dim(Y)
Y
X1
library(MASS)#
library("truncnorm")#
library(lme4)#
library(lmerTest)#
###############################################################################
### Get the core index, we will use this index as the lambda2 index      ######
###############################################################################
args=(commandArgs(TRUE))#
job = as.numeric(gsub("\\job=", "", args))#
data.index = job#
chip.size = 10#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
beta = c(rep(0,1),rep(0,n.y-1))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.5),(tmp.norm.ind<0.3)* rnorm(n,0.3,0.2)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.7,0.2))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
max(error)#
min(error)#
#
Y <- as.matrix(beta) %*% t(as.matrix(Z)) + error#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")#
rownames(Y) = paste("Y",c(1:n.y),sep="")
X1 = X#
    beta <- Y#
    beta = t(beta)#
    is.X.null = is.null(X)#
    if( is.X.null) {#
        beta1 =as.data.frame(beta)#
        beta1$chip = rep(1:length(C),each = C[1])#
        beta1$Z = Z#
    } else {#
        X = as.data.frame(X)#
        X$chip = rep(1:length(C),each = C[1])#
        X$Z = Z#
        beta1 = as.data.frame(cbind(beta,X))#
    }#
    site.list = colnames(beta)#
    n = dim(Y)[2]#
    sigsq=lapply(site.list, function(x)#
    {#
        c(var(beta1[x]))#
    }#
    ) # variance of methylation value for each site#
    names(sigsq)=site.list#
    X=Z#
    if( is.X.null) {#
        Y=cbind(rep(1,n))#
    } else {#
        Y=cbind(rep(1,n),X1) # other covariates including the intercept#
    }#
    H=Y%*%solve(t(Y)%*%Y)%*%t(Y)#
    n1=dim(H)[1]#
    I=diag(rep(1,n1))#
    IH=I-H
stat_t=lapply(site.list, function(x)#
    {#
        t(as.matrix(Z))%*%IH%*%as.matrix(beta1[x])/(sigsq[[x]])#
    }#
    )#
    T=as.vector(unlist(stat_t))#
    if(sum(is.na(T)) >0) {#
        indicator =  !is.na(T)#
        site.list = site.list[indicator]#
        sigsq=as.vector(unlist(sigsq))#
        sigsq = sigsq[indicator]#
        T = T[indicator]#
        beta2 = beta2[indicator,]#
        beta2 = beta2[,indicator]#
        fianl.indicator = 9#
    } else {#
        fianl.indicator = 1#
        sigsq=as.vector(unlist(sigsq))#
    }# delete the NA CpG sits#
    test_stat=t(T)%*%T#
    T=test_stat#
    m=length(site.list)#
    tau_sq=t(X)%*%IH%*%X#
    Delta_2=diag(c(1/(sigsq^2)))#
    Cov=c(tau_sq)*Delta_2%*%as.matrix(cov(beta2))#
    c=eigen(Cov,only.values=TRUE)$values        #chi_sq distrbn#
    a=Re(sum(c^3)/sum(c^2))#
    b=Re(sum(c)-(sum(c^2)^2)/(sum(c^3)))#
    d=Re((sum(c^2)^3)/(sum(c^3)^2))#
    pSumSqU=(1-pchisq((T-b)/a,d))
beta2
sum(is.na(T))
T
X1 = X#
    beta <- Y#
    beta = t(beta)#
    is.X.null = is.null(X)#
    if( is.X.null) {#
        beta1 =as.data.frame(beta)#
        beta1$chip = rep(1:length(C),each = C[1])#
        beta1$Z = Z#
    } else {#
        X = as.data.frame(X)#
        X$chip = rep(1:length(C),each = C[1])#
        X$Z = Z#
        beta1 = as.data.frame(cbind(beta,X))#
    }#
    site.list = colnames(beta)#
    n = dim(Y)[2]#
    sigsq=lapply(site.list, function(x)#
    {#
        c(var(beta1[x]))#
    }#
    ) # variance of methylation value for each site#
    names(sigsq)=site.list#
    X=Z#
    if( is.X.null) {#
        Y=cbind(rep(1,n))#
    } else {#
        Y=cbind(rep(1,n),X1) # other covariates including the intercept#
    }#
    H=Y%*%solve(t(Y)%*%Y)%*%t(Y)#
    n1=dim(H)[1]#
    I=diag(rep(1,n1))#
    IH=I-H#
    stat_t=lapply(site.list, function(x)#
    {#
        t(as.matrix(Z))%*%IH%*%as.matrix(beta1[x])/(sigsq[[x]])#
    }#
    )#
    T=as.vector(unlist(stat_t))
T
library(MASS)#
library("truncnorm")#
library(lme4)#
library(lmerTest)#
###############################################################################
### Get the core index, we will use this index as the lambda2 index      ######
###############################################################################
args=(commandArgs(TRUE))#
job = as.numeric(gsub("\\job=", "", args))#
data.index = job#
chip.size = 10#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
beta = c(rep(0,1),rep(0,n.y-1))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.5),(tmp.norm.ind<0.3)* rnorm(n,0.3,0.2)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.7,0.2))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
max(error)#
min(error)#
#
Y <- as.matrix(beta) %*% t(as.matrix(Z)) + error#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")#
rownames(Y) = paste("Y",c(1:n.y),sep="")
X1 = X#
    beta <- Y#
    beta = t(beta)#
    is.X.null = is.null(X)#
    if( is.X.null) {#
        beta1 =as.data.frame(beta)#
        beta1$chip = rep(1:length(C),each = C[1])#
        beta1$Z = Z#
    } else {#
        X = as.data.frame(X)#
        X$chip = rep(1:length(C),each = C[1])#
        X$Z = Z#
        beta1 = as.data.frame(cbind(beta,X))#
    }#
    site.list = colnames(beta)#
    n = dim(Y)[2]#
    sigsq=lapply(site.list, function(x)#
    {#
        c(var(beta1[x]))#
    }#
    ) # variance of methylation value for each site#
    names(sigsq)=site.list#
    X=Z#
    if( is.X.null) {#
        Y=cbind(rep(1,n))#
    } else {#
        Y=cbind(rep(1,n),X1) # other covariates including the intercept#
    }#
    H=Y%*%solve(t(Y)%*%Y)%*%t(Y)#
    n1=dim(H)[1]#
    I=diag(rep(1,n1))#
    IH=I-H#
    stat_t=lapply(site.list, function(x)#
    {#
        t(as.matrix(Z))%*%IH%*%as.matrix(beta1[x])/(sigsq[[x]])#
    }#
    )#
    T=as.vector(unlist(stat_t))
T
sum(is.na(T)) >0
is.na(T)
library(MASS)#
library("truncnorm")#
library(lme4)#
library(lmerTest)#
###############################################################################
### Get the core index, we will use this index as the lambda2 index      ######
###############################################################################
args=(commandArgs(TRUE))#
job = as.numeric(gsub("\\job=", "", args))#
data.index = job#
chip.size = 10#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
beta = c(rep(0,1),rep(0,n.y-1))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.5),(tmp.norm.ind<0.3)* rnorm(n,0.3,0.2)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.7,0.2))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
max(error)#
min(error)#
#
Y <- as.matrix(beta) %*% t(as.matrix(Z)) + error#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")#
rownames(Y) = paste("Y",c(1:n.y),sep="")
X1 = X#
    beta <- Y#
    beta = t(beta)#
    beta2 = beta#
    is.X.null = is.null(X)#
    if( is.X.null) {#
        beta1 =as.data.frame(beta)#
        beta1$chip = rep(1:length(C),each = C[1])#
        beta1$Z = Z#
    } else {#
        X = as.data.frame(X)#
        X$chip = rep(1:length(C),each = C[1])#
        X$Z = Z#
        beta1 = as.data.frame(cbind(beta,X))#
    }#
    site.list = colnames(beta)#
    n = dim(Y)[2]#
    sigsq=lapply(site.list, function(x)#
    {#
        c(var(beta1[x]))#
    }#
    ) # variance of methylation value for each site#
    names(sigsq)=site.list#
    X=Z#
    if( is.X.null) {#
        Y=cbind(rep(1,n))#
    } else {#
        Y=cbind(rep(1,n),X1) # other covariates including the intercept#
    }#
    H=Y%*%solve(t(Y)%*%Y)%*%t(Y)#
    n1=dim(H)[1]#
    I=diag(rep(1,n1))#
    IH=I-H#
    stat_t=lapply(site.list, function(x)#
    {#
        t(as.matrix(Z))%*%IH%*%as.matrix(beta1[x])/(sigsq[[x]])#
    }#
    )#
    T=as.vector(unlist(stat_t))#
    if(sum(is.na(T)) >0) {#
        indicator =  !is.na(T)#
        site.list = site.list[indicator]#
        sigsq=as.vector(unlist(sigsq))#
        sigsq = sigsq[indicator]#
        T = T[indicator]#
        beta2 = beta2[indicator,]#
        beta2 = beta2[,indicator]#
        fianl.indicator = 9#
    } else {#
        fianl.indicator = 1#
        sigsq=as.vector(unlist(sigsq))#
    }# delete the NA CpG sits#
    test_stat=t(T)%*%T#
    T=test_stat#
    m=length(site.list)#
    tau_sq=t(X)%*%IH%*%X#
    Delta_2=diag(c(1/(sigsq^2)))#
    Cov=c(tau_sq)*Delta_2%*%as.matrix(cov(beta2))
dim(as.matrix(cov(beta2)))
dim(Delta_2)
c=eigen(Cov,only.values=TRUE)$values        #chi_sq distrbn#
    a=Re(sum(c^3)/sum(c^2))#
    b=Re(sum(c)-(sum(c^2)^2)/(sum(c^3)))#
    d=Re((sum(c^2)^3)/(sum(c^3)^2))#
    pSumSqU=(1-pchisq((T-b)/a,d))
pSumSqU
C
sum(C)
sigma
sigma[1:20,1:20]
dim(X)
##################################
#
library(MASS)#
library("truncnorm")#
library(lme4)#
library(lmerTest)#
###############################################################################
### Get the core index, we will use this index as the lambda2 index      ######
###############################################################################
args=(commandArgs(TRUE))#
job = as.numeric(gsub("\\job=", "", args))#
data.index = job#
chip.size = 10#
#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
beta = c(rep(0,1),rep(0,n.y-1))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.5),(tmp.norm.ind<0.3)* rnorm(n,0.3,0.2)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.7,0.2))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)
X
dim(error)
dim(X)
matrix(rep(c(0.1,0.5),times = n.y),2,n.y)
t(X %*% matrix(rep(c(0.1,0.5),times = n.y),n.y,2) )
dim(X)
t(X %*% matrix(rep(c(0.1,0.5),times = n.y),2,n.y) )
Y <- t(X %*% matrix(rep(c(0.1,0.5),times = n.y),2,n.y) ) + as.matrix(beta) %*% t(as.matrix(Z)) + error
Y
hist(Y)
hist(error)
hist( t(X %*% matrix(rep(c(0.1,0.5),times = n.y),2,n.y) ))
library(MASS)#
library("truncnorm")#
library(lme4)#
library(lmerTest)#
###############################################################################
### Get the core index, we will use this index as the lambda2 index      ######
###############################################################################
args=(commandArgs(TRUE))#
job = as.numeric(gsub("\\job=", "", args))#
data.index = job#
chip.size = 10#
#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
beta = c(rep(0,1),rep(0,n.y-1))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.6),(tmp.norm.ind<0.3)* rnorm(n,0.3,0.2)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.8,0.2))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
Y <- t(X %*% matrix(rep(c(0.1,0.5),times = n.y),2,n.y) ) + as.matrix(beta) %*% t(as.matrix(Z)) + error#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")#
rownames(Y) = paste("Y",c(1:n.y),sep="")#
SumSqU2(Y,X,Z,C)
SumSqU2 <- function(Y, X, Z,C) {#
    X1 = X#
    beta <- Y#
    beta = t(beta)#
    beta2 = beta#
    is.X.null = is.null(X)#
    if( is.X.null) {#
        beta1 =as.data.frame(beta)#
        beta1$chip = rep(1:length(C),each = C[1])#
        beta1$Z = Z#
    } else {#
        X = as.data.frame(X)#
        X$chip = rep(1:length(C),each = C[1])#
        X$Z = Z#
        beta1 = as.data.frame(cbind(beta,X))#
    }#
    site.list = colnames(beta)#
    n = dim(Y)[2]#
    sigsq=lapply(site.list, function(x)#
    {#
        c(var(beta1[x]))#
    }#
    ) # variance of methylation value for each site#
    names(sigsq)=site.list#
    X=Z#
    if( is.X.null) {#
        Y=cbind(rep(1,n))#
    } else {#
        Y=cbind(rep(1,n),X1) # other covariates including the intercept#
    }#
    H=Y%*%solve(t(Y)%*%Y)%*%t(Y)#
    n1=dim(H)[1]#
    I=diag(rep(1,n1))#
    IH=I-H#
    stat_t=lapply(site.list, function(x)#
    {#
        t(as.matrix(Z))%*%IH%*%as.matrix(beta1[x])/(sigsq[[x]])#
    }#
    )#
    T=as.vector(unlist(stat_t))#
    if(sum(is.na(T)) >0) {#
        indicator =  !is.na(T)#
        site.list = site.list[indicator]#
        sigsq=as.vector(unlist(sigsq))#
        sigsq = sigsq[indicator]#
        T = T[indicator]#
        beta2 = beta2[indicator,]#
        beta2 = beta2[,indicator]#
        fianl.indicator = 9#
    } else {#
        fianl.indicator = 1#
        sigsq=as.vector(unlist(sigsq))#
    }# delete the NA CpG sits#
    test_stat=t(T)%*%T#
    T=test_stat#
    m=length(site.list)#
    tau_sq=t(X)%*%IH%*%X#
    Delta_2=diag(c(1/(sigsq^2)))#
    Cov=c(tau_sq)*Delta_2%*%as.matrix(cov(beta2))#
    c=eigen(Cov,only.values=TRUE)$values        #chi_sq distrbn#
    a=Re(sum(c^3)/sum(c^2))#
    b=Re(sum(c)-(sum(c^2)^2)/(sum(c^3)))#
    d=Re((sum(c^2)^3)/(sum(c^3)^2))#
    pSumSqU=(1-pchisq((T-b)/a,d))#
    out.put = matrix(NA,1,2)#
    colnames(out.put) = c("pvalue","indicator")#
    out.put[1,] = c(pSumSqU,fianl.indicator)#
    out#
}
library(MASS)#
library("truncnorm")#
library(lme4)#
library(lmerTest)#
###############################################################################
### Get the core index, we will use this index as the lambda2 index      ######
###############################################################################
args=(commandArgs(TRUE))#
job = as.numeric(gsub("\\job=", "", args))#
data.index = job#
chip.size = 10#
#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
beta = c(rep(0,1),rep(0,n.y-1))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.6),(tmp.norm.ind<0.3)* rnorm(n,0.3,0.2)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.8,0.2))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
Y <- t(X %*% matrix(rep(c(0.1,0.5),times = n.y),2,n.y) ) + as.matrix(beta) %*% t(as.matrix(Z)) + error#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")#
rownames(Y) = paste("Y",c(1:n.y),sep="")#
SumSqU2(Y,X,Z,C)
SumSqU2 <- function(Y, X, Z,C) {#
    X1 = X#
    beta <- Y#
    beta = t(beta)#
    beta2 = beta#
    is.X.null = is.null(X)#
    if( is.X.null) {#
        beta1 =as.data.frame(beta)#
        beta1$chip = rep(1:length(C),each = C[1])#
        beta1$Z = Z#
    } else {#
        X = as.data.frame(X)#
        X$chip = rep(1:length(C),each = C[1])#
        X$Z = Z#
        beta1 = as.data.frame(cbind(beta,X))#
    }#
    site.list = colnames(beta)#
    n = dim(Y)[2]#
    sigsq=lapply(site.list, function(x)#
    {#
        c(var(beta1[x]))#
    }#
    ) # variance of methylation value for each site#
    names(sigsq)=site.list#
    X=Z#
    if( is.X.null) {#
        Y=cbind(rep(1,n))#
    } else {#
        Y=cbind(rep(1,n),X1) # other covariates including the intercept#
    }#
    H=Y%*%solve(t(Y)%*%Y)%*%t(Y)#
    n1=dim(H)[1]#
    I=diag(rep(1,n1))#
    IH=I-H#
    stat_t=lapply(site.list, function(x)#
    {#
        t(as.matrix(Z))%*%IH%*%as.matrix(beta1[x])/(sigsq[[x]])#
    }#
    )#
    T=as.vector(unlist(stat_t))#
    if(sum(is.na(T)) >0) {#
        indicator =  !is.na(T)#
        site.list = site.list[indicator]#
        sigsq=as.vector(unlist(sigsq))#
        sigsq = sigsq[indicator]#
        T = T[indicator]#
        beta2 = beta2[indicator,]#
        beta2 = beta2[,indicator]#
        fianl.indicator = 9#
    } else {#
        fianl.indicator = 1#
        sigsq=as.vector(unlist(sigsq))#
    }# delete the NA CpG sits#
    test_stat=t(T)%*%T#
    T=test_stat#
    m=length(site.list)#
    tau_sq=t(X)%*%IH%*%X#
    Delta_2=diag(c(1/(sigsq^2)))#
    Cov=c(tau_sq)*Delta_2%*%as.matrix(cov(beta2))#
    c=eigen(Cov,only.values=TRUE)$values        #chi_sq distrbn#
    a=Re(sum(c^3)/sum(c^2))#
    b=Re(sum(c)-(sum(c^2)^2)/(sum(c^3)))#
    d=Re((sum(c^2)^3)/(sum(c^3)^2))#
    pSumSqU=(1-pchisq((T-b)/a,d))#
    out.put = matrix(NA,1,2)#
    colnames(out.put) = c("pvalue","indicator")#
    out.put[1,] = c(pSumSqU,fianl.indicator)#
    out.put#
}
library(MASS)#
library("truncnorm")#
library(lme4)#
library(lmerTest)#
###############################################################################
### Get the core index, we will use this index as the lambda2 index      ######
###############################################################################
args=(commandArgs(TRUE))#
job = as.numeric(gsub("\\job=", "", args))#
data.index = job#
chip.size = 10#
#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
beta = c(rep(0,1),rep(0,n.y-1))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.6),(tmp.norm.ind<0.3)* rnorm(n,0.3,0.2)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.8,0.2))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
Y <- t(X %*% matrix(rep(c(0.1,0.5),times = n.y),2,n.y) ) + as.matrix(beta) %*% t(as.matrix(Z)) + error#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")#
rownames(Y) = paste("Y",c(1:n.y),sep="")#
SumSqU2(Y,X,Z,C)
X
hist(X[,2])
hist(X[,2],breaks = 50)
tmp.norm.ind
sum((tmp.norm.ind>=0.3))
t(X %*% matrix(rep(c(0.1,0.5),times = n.y),2,n.y) )
max(t(X %*% matrix(rep(c(0.1,0.5),times = n.y),2,n.y) ))
min(t(X %*% matrix(rep(c(0.1,0.5),times = n.y),2,n.y) ))
t(X %*% matrix(rep(c(0.01,0.05),times = n.y),2,n.y) )
library(MASS)#
library("truncnorm")#
library(lme4)#
library(lmerTest)#
###############################################################################
### Get the core index, we will use this index as the lambda2 index      ######
###############################################################################
args=(commandArgs(TRUE))#
job = as.numeric(gsub("\\job=", "", args))#
data.index = job#
chip.size = 10#
#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
beta = c(rep(0,1),rep(0,n.y-1))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.6),(tmp.norm.ind<0.3)* rnorm(n,0.2,0.1)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.8,0.1))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
Y <- t(X %*% matrix(rep(c(0.01,0.05),times = n.y),2,n.y) ) + as.matrix(beta) %*% t(as.matrix(Z)) + error#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")#
rownames(Y) = paste("Y",c(1:n.y),sep="")#
SumSqU2(Y,X,Z,C)
library(MASS)#
library("truncnorm")#
library(lme4)#
library(lmerTest)#
###############################################################################
### Get the core index, we will use this index as the lambda2 index      ######
###############################################################################
args=(commandArgs(TRUE))#
job = as.numeric(gsub("\\job=", "", args))#
data.index = job#
chip.size = 10#
#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
beta = c(rep(0,1),rep(0,n.y-1))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.6),(tmp.norm.ind<0.3)* rnorm(n,0.2,0.1)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.8,0.1))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
Y <- t(X %*% matrix(rep(c(0.01,0.1),times = n.y),2,n.y) ) + as.matrix(beta) %*% t(as.matrix(Z)) + error#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")#
rownames(Y) = paste("Y",c(1:n.y),sep="")#
SumSqU2(Y,X,Z,C)
t(X %*% matrix(rep(c(0.05,0.1),times = n.y),2,n.y) )
max( t(X %*% matrix(rep(c(0.05,0.1),times = n.y),2,n.y) ))
Y <- t(X %*% matrix(rep(c(0.05,0.1),times = n.y),2,n.y) ) + as.matrix(beta) %*% t(as.matrix(Z)) + error
max(Y)
min(Y)
library(MASS)#
library("truncnorm")#
library(lme4)#
library(lmerTest)#
###############################################################################
### Get the core index, we will use this index as the lambda2 index      ######
###############################################################################
args=(commandArgs(TRUE))#
job = as.numeric(gsub("\\job=", "", args))#
data.index = job#
chip.size = 10#
#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
informative.num = 5#
beta = c(rep(0.5,informative.num),rep(0,n.y-informative.num))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.6),(tmp.norm.ind<0.3)* rnorm(n,0.2,0.1)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.8,0.1))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
Y <- t(X %*% matrix(rep(c(0.05,0.1),times = n.y),2,n.y) ) + as.matrix(beta) %*% t(as.matrix(Z)) + error#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")#
rownames(Y) = paste("Y",c(1:n.y),sep="")#
SumSqU2(Y,X,Z,C)
##################################
### Simulation 1              ####
##################################
#
library(MASS)#
library("truncnorm")#
library(lme4)#
library(lmerTest)#
###############################################################################
### Get the core index, we will use this index as the lambda2 index      ######
###############################################################################
args=(commandArgs(TRUE))#
job = as.numeric(gsub("\\job=", "", args))#
data.index = job#
chip.size = 10#
#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
informative.num = 5#
beta = c(rep(0,informative.num),rep(0,n.y-informative.num))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.6),(tmp.norm.ind<0.3)* rnorm(n,0.2,0.1)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.8,0.1))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
Y <- t(X %*% matrix(rep(c(0.05,0.1),times = n.y),2,n.y) ) + as.matrix(beta) %*% t(as.matrix(Z)) + error#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")#
rownames(Y) = paste("Y",c(1:n.y),sep="")#
SumSqU2(Y,X,Z,C)
res = matrix(NA,1000,2)#
for(index in 1:1000){#
chip.size = 10#
#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
informative.num = 5#
beta = c(rep(0,informative.num),rep(0,n.y-informative.num))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.6),(tmp.norm.ind<0.3)* rnorm(n,0.2,0.1)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.8,0.1))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
Y <- t(X %*% matrix(rep(c(0.05,0.1),times = n.y),2,n.y) ) + as.matrix(beta) %*% t(as.matrix(Z)) + error#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")#
rownames(Y) = paste("Y",c(1:n.y),sep="")#
res[index,] = SumSqU2(Y,X,Z,C)#
}
min(res[,1]
)
min(res[,1])
library(MASS)#
library("truncnorm")#
library(lme4)#
library(lmerTest)#
###############################################################################
### Get the core index, we will use this index as the lambda2 index      ######
###############################################################################
args=(commandArgs(TRUE))#
job = as.numeric(gsub("\\job=", "", args))#
data.index = job#
res = matrix(NA,1000,2)#
for(index in 1:1000){#
chip.size = 10#
#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
informative.num = 5#
beta = c(rep(0,informative.num),rep(0,n.y-informative.num))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.6),(tmp.norm.ind<0.3)* rnorm(n,0.2,0.1)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.8,0.1))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
#Y <- t(X %*% matrix(rep(c(0.05,0.1),times = n.y),2,n.y) ) + as.matrix(beta) %*% t(as.matrix(Z)) + error#
Y <- as.matrix(beta) %*% t(as.matrix(Z)) + error#
#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")#
rownames(Y) = paste("Y",c(1:n.y),sep="")#
X = NULL#
res[index,] = SumSqU2(Y,X,Z,C)#
}
min(res[,1])
sum(res[,1]<0.05)/1000
as.matrix(beta) %*% t(as.matrix(Z))
beta = c(rep(0.5,informative.num),rep(0,n.y-informative.num))
as.matrix(beta) %*% t(as.matrix(Z))
mean(error)
mean(error[1,])
mean(error[,1])
mean(error[1,])
n.y
?mvrnorm
SumSqU <- function(Y, X, Z,C) {#
    beta <- Y#
    beta = t(beta)#
    is.X.null = is.null(X)#
    if( is.X.null) {#
        beta1 =as.data.frame(beta)#
        beta1$chip = rep(1:length(C),each = C[1])#
        beta1$Z = Z#
    } else {#
        X = as.data.frame(X)#
        X$chip = rep(1:length(C),each = C[1])#
        X$Z = Z#
        beta1 = as.data.frame(cbind(beta,X))#
    }#
    site.list = colnames(beta)#
    n = dim(Y)[2]#
    mix_eff_cov=lapply(site.list, function(x)     #mixed models#
    {#
        if(is.X.null) {#
            formula = as.formula(paste(x,"~(1|chip)+Z", sep=""))#
        } else {#
            formula = as.formula(paste(x,"~(1|chip)+Z + X1 + X2", sep=""))#
        }#
        model =try (do.call("lmer", args = list(formula,data=beta1,na.action="na.exclude")))#
        if (inherits(model, "try-error")) {#
            c("NA")#
        } else {#
            v_a=as.data.frame(VarCorr(model))[1,4]        #var of batch eff#
            v_e=as.data.frame(VarCorr(model))[2,4]      #var of error#
            Cov=matrix(0,n,n)                        #list for block diagonal matrix#
            tmp.D.index1 = 1#
            for ( i in 1:length(C))#
            {#
                tmp.D.index2 = tmp.D.index1 + C[i]-1#
            Cov[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]=solve(matrix(rep(v_a,C[i]*C[i]),C[i],C[i]) + diag(v_e,C[i]))# matrix(rep(v_a,C[i]*C[i]),C[i],C[i]) + diag(v_e,C[i]) ##
                tmp.D.index1 = tmp.D.index2 + 1#
            }#
            return(Cov)#
        }#
    }#
    ) ## calcluate the Sigma_k in the LMM, we will use it in the future. The main difference between SKAT and this method#
    names(mix_eff_cov)=site.list#
    tilde.x = cbind(rep(1,n), beta1$X1,beta1$X2)#
    score_stat=lapply(site.list, function(x)     #score stats for m sites#
    {#
        hat.beta = (solve(t(tilde.x) %*% mix_eff_cov[[x]] %*% tilde.x)) %*% (t(tilde.x) %*% mix_eff_cov[[x]] %*%as.matrix(beta1[x]))#
        s=t(beta1[x])%*%mix_eff_cov[[x]] %*% beta1$Z-t(hat.beta) %*% t(tilde.x) %*% mix_eff_cov[[x]] %*% beta1$Z#
    }#
    )#
    U=as.vector(unlist(score_stat))#
    if(sum(is.na(U)) >0) {#
        indicator =  !is.na(U)#
        site.list = site.list[indicator]#
        mix_eff_cov = mix_eff_cov[indicator]#
        U = U[indicator]#
        fianl.indicator = 9#
    } else {#
        fianl.indicator = 1#
    }# delete the NA CpG sits#
    m=length(site.list)#
    T=t(U)%*%U                                    #SumSqU test statistic#
    CovS=matrix(0,m,m)                        #cov of the m score stats#
    tmp =list()#
    sigma = list()#
    tmp.x = list()#
    for(i in 1:m) {#
        tmp[[i]] =  beta1$Z %*% mix_eff_cov[[i]] %*%tilde.x %*% (solve(t(tilde.x) %*% mix_eff_cov[[i]] %*% tilde.x))#
        sigma[[i]] = beta1$Z %*% mix_eff_cov[[i]]#
        tmp.x[[i]] = t(tilde.x) %*% mix_eff_cov[[i]]#
    }#
    for ( i in 1:m)#
    {#
        for ( j in 1:i)#
        {#
            CovS[i,j]=CovS[j,i]= cov(beta1[site.list[i]],beta1[site.list[j]]) * ( sigma[[i]] %*% t(sigma[[j]]) - tmp[[i]] %*% tmp.x[[i]] %*% t(sigma[[j]]) - tmp[[j]] %*% tmp.x[[j]] %*% t(sigma[[i]]) +  tmp[[i]] %*% tmp.x[[i]] %*% t(tmp.x[[j]]) %*% t(tmp[[j]]) )#
        }#
    }#
    c=eigen(CovS,only.values=TRUE)$values        #chi_sq distrbn#
    a=Re(sum(c^3)/sum(c^2))#
    b=Re(sum(c)-(sum(c^2)^2)/(sum(c^3)))#
    d=Re((sum(c^2)^3)/(sum(c^3)^2))#
    pSumSqU=(1-pchisq((T-b)/a,d))#
    out.put = matrix(NA,1,2)#
    colnames(out.put) = c("pvalue","indicator")#
    out.put[1,] = c(pSumSqU, fianl.indicator)#
    out.put#
}
library(MASS)#
library("truncnorm")#
library(lme4)#
library(lmerTest)#
###############################################################################
### Get the core index, we will use this index as the lambda2 index      ######
###############################################################################
args=(commandArgs(TRUE))#
job = as.numeric(gsub("\\job=", "", args))#
data.index = job#
res = matrix(NA,1000,2)#
for(index in 1:1000){#
chip.size = 10#
#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
informative.num = 5#
beta = c(rep(0.5,informative.num),rep(0,n.y-informative.num))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.6),(tmp.norm.ind<0.3)* rnorm(n,0.2,0.1)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.8,0.1))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
#Y <- t(X %*% matrix(rep(c(0.05,0.1),times = n.y),2,n.y) ) + as.matrix(beta) %*% t(as.matrix(Z)) + error#
Y <- as.matrix(beta) %*% t(as.matrix(Z)) + error#
#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")#
rownames(Y) = paste("Y",c(1:n.y),sep="")#
X = NULL#
res[index,] = SumSqU(Y,X,Z,C)#
}#
#
min(res[,1])#
sum(res[,1]<0.05)/1000
res
chip.size = 10#
#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
informative.num = 5#
beta = c(rep(0.5,informative.num),rep(0,n.y-informative.num))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.6),(tmp.norm.ind<0.3)* rnorm(n,0.2,0.1)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.8,0.1))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
#Y <- t(X %*% matrix(rep(c(0.05,0.1),times = n.y),2,n.y) ) + as.matrix(beta) %*% t(as.matrix(Z)) + error#
Y <- as.matrix(beta) %*% t(as.matrix(Z)) + error#
#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")#
rownames(Y) = paste("Y",c(1:n.y),sep="")#
X = NULL
SumSqU(Y,X,Z,C)
chip.size = 10#
#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
informative.num = 5#
beta = c(rep(0,informative.num),rep(0,n.y-informative.num))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.6),(tmp.norm.ind<0.3)* rnorm(n,0.2,0.1)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.8,0.1))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
#Y <- t(X %*% matrix(rep(c(0.05,0.1),times = n.y),2,n.y) ) + as.matrix(beta) %*% t(as.matrix(Z)) + error#
Y <- as.matrix(beta) %*% t(as.matrix(Z)) + error#
#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")#
rownames(Y) = paste("Y",c(1:n.y),sep="")#
X = NULL
SumSqU(Y,X,Z,C)
res = matrix(NA,100,2)#
for(index in 1:100){#
chip.size = 10#
#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
informative.num = 5#
beta = c(rep(0,informative.num),rep(0,n.y-informative.num))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.6),(tmp.norm.ind<0.3)* rnorm(n,0.2,0.1)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.8,0.1))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
#Y <- t(X %*% matrix(rep(c(0.05,0.1),times = n.y),2,n.y) ) + as.matrix(beta) %*% t(as.matrix(Z)) + error#
Y <- as.matrix(beta) %*% t(as.matrix(Z)) + error#
#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")#
rownames(Y) = paste("Y",c(1:n.y),sep="")#
X = NULL#
#
res[index,] = SumSqU(Y,X,Z,C)#
}
res
quantile(res[,1])
n = 100
cbind(rep(1,n))
class( cbind(rep(1,n)))
for(index in 1:100){#
chip.size = 10#
#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 1 # number of CpG sites in the gene#
#
informative.num = 1#
beta = c(rep(0,informative.num),rep(0,n.y-informative.num))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.6),(tmp.norm.ind<0.3)* rnorm(n,0.2,0.1)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.8,0.1))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
#
#Y <- t(X %*% matrix(rep(c(0.05,0.1),times = n.y),2,n.y) ) + as.matrix(beta) %*% t(as.matrix(Z)) + error#
Y <- as.matrix(beta) %*% t(as.matrix(Z)) + error#
#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")#
rownames(Y) = paste("Y",c(1:n.y),sep="")#
X = NULL#
#
res[index,] = SumSqU(Y,X,Z,C)#
}
res
min(res)
sum(res[,1]<0.05)/100
SumSqU2 <- function(Y, X, Z,C) {#
    X1 = X#
    beta <- Y#
    beta = t(beta)#
    beta2 = beta#
    is.X.null = is.null(X)#
    if( is.X.null) {#
        beta1 =as.data.frame(beta)#
        beta1$chip = rep(1:length(C),each = C[1])#
        beta1$Z = Z#
    } else {#
        X = as.data.frame(X)#
        X$chip = rep(1:length(C),each = C[1])#
        X$Z = Z#
        beta1 = as.data.frame(cbind(beta,X))#
    }#
    site.list = colnames(beta)#
    n = dim(Y)[2]#
    sigsq=lapply(site.list, function(x)#
    {#
        c(var(beta1[x]))#
    }#
    ) # variance of methylation value for each site#
    names(sigsq)=site.list#
    X=Z#
    if( is.X.null) {#
        Y=cbind(rep(1,n))#
    } else {#
        Y=cbind(rep(1,n),X1) # other covariates including the intercept#
    }#
    H=Y%*%solve(t(Y)%*%Y)%*%t(Y)#
    n1=dim(H)[1]#
    I=diag(rep(1,n1))#
    IH=I-H#
    stat_t=lapply(site.list, function(x)#
    {#
        t(as.matrix(Z))%*%IH%*%as.matrix(beta1[x])/(sigsq[[x]])#
    }#
    )#
    T=as.vector(unlist(stat_t))#
    if(sum(is.na(T)) >0) {#
        indicator =  !is.na(T)#
        site.list = site.list[indicator]#
        sigsq=as.vector(unlist(sigsq))#
        sigsq = sigsq[indicator]#
        T = T[indicator]#
        beta2 = beta2[indicator,]#
        beta2 = beta2[,indicator]#
        fianl.indicator = 9#
    } else {#
        fianl.indicator = 1#
        sigsq=as.vector(unlist(sigsq))#
    }# delete the NA CpG sits#
    test_stat=t(T)%*%T#
    T=test_stat#
    m=length(site.list)#
    tau_sq=t(X)%*%IH%*%X#
    Delta_2=diag(c(1/(sigsq^2)))#
    Cov=c(tau_sq)*Delta_2%*%as.matrix(cov(beta2))#
    c=eigen(Cov,only.values=TRUE)$values        #chi_sq distrbn#
    a=Re(sum(c^3)/sum(c^2))#
    b=Re(sum(c)-(sum(c^2)^2)/(sum(c^3)))#
    d=Re((sum(c^2)^3)/(sum(c^3)^2))#
    pSumSqU=(1-pchisq((T-b)/a,d))#
    out.put = matrix(NA,1,2)#
    colnames(out.put) = c("pvalue","indicator")#
    out.put[1,] = c(pSumSqU,fianl.indicator)#
    out.put#
}
res = matrix(NA,1000,2)#
for(index in 1:1000){#
chip.size = 10#
#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
informative.num = 1#
beta = c(rep(0,informative.num),rep(0,n.y-informative.num))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.6),(tmp.norm.ind<0.3)* rnorm(n,0.2,0.1)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.8,0.1))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
#
#Y <- t(X %*% matrix(rep(c(0.05,0.1),times = n.y),2,n.y) ) + as.matrix(beta) %*% t(as.matrix(Z)) + error#
Y <- as.matrix(beta) %*% t(as.matrix(Z)) + error#
#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")#
rownames(Y) = paste("Y",c(1:n.y),sep="")#
X = NULL#
#
res[index,] = SumSqU2(Y,X,Z,C)#
}
min(res[,1])#
sum(res[,1]<0.05)/1000
chip.size = 10#
#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
informative.num = 1#
beta = c(rep(0,informative.num),rep(0,n.y-informative.num))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.6),(tmp.norm.ind<0.3)* rnorm(n,0.2,0.1)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.8,0.1))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
#
#Y <- t(X %*% matrix(rep(c(0.05,0.1),times = n.y),2,n.y) ) + as.matrix(beta) %*% t(as.matrix(Z)) + error#
Y <- as.matrix(beta) %*% t(as.matrix(Z)) + error#
#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")#
rownames(Y) = paste("Y",c(1:n.y),sep="")#
X = NULL
### Simulation 1              ####
##################################
#
library(MASS)#
library("truncnorm")#
library(lme4)#
library(lmerTest)#
library(permute)#
###############################################################################
### Get the core index, we will use this index as the lambda2 index      ######
###############################################################################
args=(commandArgs(TRUE))#
job = as.numeric(gsub("\\job=", "", args))#
data.index = job
chip.size = 10#
#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
informative.num = 1#
beta = c(rep(0,informative.num),rep(0,n.y-informative.num))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.6),(tmp.norm.ind<0.3)* rnorm(n,0.2,0.1)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.8,0.1))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
#
#Y <- t(X %*% matrix(rep(c(0.05,0.1),times = n.y),2,n.y) ) + as.matrix(beta) %*% t(as.matrix(Z)) + error#
Y <- as.matrix(beta) %*% t(as.matrix(Z)) + error#
#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")#
rownames(Y) = paste("Y",c(1:n.y),sep="")#
X = NULL
beta <- Y#
    beta = t(beta)#
    is.X.null = is.null(X)#
    if( is.X.null) {#
        beta1 =as.data.frame(beta)#
        beta1$chip = rep(1:length(C),each = C[1])#
        beta1$Z = Z#
    } else {#
        X = as.data.frame(X)#
        X$chip = rep(1:length(C),each = C[1])#
        X$Z = Z#
        beta1 = as.data.frame(cbind(beta,X))#
    }#
    site.list = colnames(beta)#
    n = dim(Y)[2]
x = site.list[1]
if(is.X.null) {#
            formula = as.formula(paste(x,"~(1|chip)+Z", sep=""))#
        } else {#
            formula = as.formula(paste(x,"~(1|chip)+Z + X1 + X2", sep=""))#
        }#
        model =try (do.call("lmer", args = list(formula,data=beta1,na.action="na.exclude")))#
        if (inherits(model, "try-error")) {#
            c("NA")#
        } else {#
            v_a=as.data.frame(VarCorr(model))[1,4]        #var of batch eff#
            v_e=as.data.frame(VarCorr(model))[2,4]      #var of error#
            Cov=matrix(0,n,n)                        #list for block diagonal matrix#
            tmp.D.index1 = 1#
            for ( i in 1:length(C))#
            {#
                tmp.D.index2 = tmp.D.index1 + C[i]-1#
            Cov[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]=solve(matrix(rep(v_a,C[i]*C[i]),C[i],C[i]) + diag(v_e,C[i]))# matrix(rep(v_a,C[i]*C[i]),C[i],C[i]) + diag(v_e,C[i]) ##
                tmp.D.index1 = tmp.D.index2 + 1#
            }#
            return(Cov)#
        }
as.data.frame(VarCorr(model))
Cov[1:10,1:10]
sigma[1:10,1:10]
solve(sigma[1:10,1:10])
names(mix_eff_cov) = site.list#
    if(is.X.null) {#
        tilde.x = cbind(rep(1,n))#
    } else {#
        tilde.x = cbind(rep(1,n), beta1$X1,beta1$X2)#
    }#
    score_stat=lapply(site.list, function(x)     #score stats for m sites#
    {#
        hat.beta = (solve(t(tilde.x) %*% mix_eff_cov[[x]] %*% tilde.x)) %*% (t(tilde.x) %*% mix_eff_cov[[x]] %*%as.matrix(beta1[x]))#
        s=t(beta1[x])%*%mix_eff_cov[[x]] %*% beta1$Z - t(hat.beta) %*% t(tilde.x) %*% mix_eff_cov[[x]] %*% beta1$Z#
    }#
    )
？Re
?Re
chip.size = 10#
#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20 # number of CpG sites in the gene#
#
informative.num = 1#
beta = c(rep(0,informative.num),rep(0,n.y-informative.num))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.6),(tmp.norm.ind<0.3)* rnorm(n,0.2,0.1)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.8,0.1))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
#
#Y <- t(X %*% matrix(rep(c(0.05,0.1),times = n.y),2,n.y) ) + as.matrix(beta) %*% t(as.matrix(Z)) + error#
Y <- as.matrix(beta) %*% t(as.matrix(Z)) + error#
#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")#
rownames(Y) = paste("Y",c(1:n.y),sep="")#
X = NULL
chip.size = 10#
#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 2# number of CpG sites in the gene#
#
informative.num = 1#
beta = c(rep(0,informative.num),rep(0,n.y-informative.num))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.6),(tmp.norm.ind<0.3)* rnorm(n,0.2,0.1)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.8,0.1))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
#
#Y <- t(X %*% matrix(rep(c(0.05,0.1),times = n.y),2,n.y) ) + as.matrix(beta) %*% t(as.matrix(Z)) + error#
Y <- as.matrix(beta) %*% t(as.matrix(Z)) + error#
#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")#
rownames(Y) = paste("Y",c(1:n.y),sep="")
beta <- Y#
    beta = t(beta)#
    is.X.null = is.null(X)#
    if( is.X.null) {#
        beta1 =as.data.frame(beta)#
        beta1$chip = rep(1:length(C),each = C[1])#
        beta1$Z = Z#
    } else {#
        X = as.data.frame(X)#
        X$chip = rep(1:length(C),each = C[1])#
        X$Z = Z#
        beta1 = as.data.frame(cbind(beta,X))#
    }#
    site.list = colnames(beta)#
    n = dim(Y)[2]#
    mix_eff_cov=lapply(site.list, function(x)     #mixed models#
    {#
        if(is.X.null) {#
            formula = as.formula(paste(x,"~(1|chip)+Z", sep=""))#
        } else {#
            formula = as.formula(paste(x,"~(1|chip)+Z + X1 + X2", sep=""))#
        }#
        model =try (do.call("lmer", args = list(formula,data=beta1,na.action="na.exclude")))#
        if (inherits(model, "try-error")) {#
            c("NA")#
        } else {#
            v_a=as.data.frame(VarCorr(model))[1,4]        #var of batch eff#
            v_e=as.data.frame(VarCorr(model))[2,4]      #var of error#
            Cov=matrix(0,n,n)                        #list for block diagonal matrix#
            tmp.D.index1 = 1#
            for ( i in 1:length(C))#
            {#
                tmp.D.index2 = tmp.D.index1 + C[i]-1#
            Cov[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]=solve(matrix(rep(v_a,C[i]*C[i]),C[i],C[i]) + diag(v_e,C[i]))# matrix(rep(v_a,C[i]*C[i]),C[i],C[i]) + diag(v_e,C[i]) ##
                tmp.D.index1 = tmp.D.index2 + 1#
            }#
            return(Cov)#
        }#
    }#
    ) ## calcluate the Sigma_k in the LMM, we will use it in the future. The main difference between SKAT and this method#
    names(mix_eff_cov) = site.list#
    if(is.X.null) {#
        tilde.x = cbind(rep(1,n))#
    } else {#
        tilde.x = cbind(rep(1,n), beta1$X1,beta1$X2)#
    }
site.list
beta1[1:5,]
rep(0,n)
dim(beta1)
sigma
mvrnorm(n = 2, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)
tmp.res = matrix(NA,10000,2)#
    for (i in 1:10000) {#
        beta1[1:2,] = t(mvrnorm(n = 2, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE))#
    score_stat=lapply(site.list, function(x)     #score stats for m sites#
    {#
        hat.beta = (solve(t(tilde.x) %*% mix_eff_cov[[x]] %*% tilde.x)) %*% (t(tilde.x) %*% mix_eff_cov[[x]] %*%as.matrix(beta1[x]))#
        s=t(beta1[x]) %*% mix_eff_cov[[x]] %*% beta1$Z - t(hat.beta) %*% t(tilde.x) %*% mix_eff_cov[[x]] %*% beta1$Z#
    }#
    )#
    tmp.res[i,] = as.vector(unlist(score_stat))#
    }
##################################
### Simulation 1              ####
##################################
#
library(MASS)#
library("truncnorm")#
library(lme4)#
library(lmerTest)#
library(permute)#
###############################################################################
### Get the core index, we will use this index as the lambda2 index      ######
###############################################################################
args=(commandArgs(TRUE))#
job = as.numeric(gsub("\\job=", "", args))#
data.index = job#
res = matrix(NA,1000,2)
chip.size = 10#
#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 2# number of CpG sites in the gene#
#
informative.num = 1#
beta = c(rep(0,informative.num),rep(0,n.y-informative.num))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.6),(tmp.norm.ind<0.3)* rnorm(n,0.2,0.1)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.8,0.1))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
#
#Y <- t(X %*% matrix(rep(c(0.05,0.1),times = n.y),2,n.y) ) + as.matrix(beta) %*% t(as.matrix(Z)) + error#
Y <- as.matrix(beta) %*% t(as.matrix(Z)) + error#
#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")#
rownames(Y) = paste("Y",c(1:n.y),sep="")
beta <- Y#
    beta = t(beta)#
    is.X.null = is.null(X)#
    if( is.X.null) {#
        beta1 =as.data.frame(beta)#
        beta1$chip = rep(1:length(C),each = C[1])#
        beta1$Z = Z#
    } else {#
        X = as.data.frame(X)#
        X$chip = rep(1:length(C),each = C[1])#
        X$Z = Z#
        beta1 = as.data.frame(cbind(beta,X))#
    }#
    site.list = colnames(beta)#
    n = dim(Y)[2]#
    mix_eff_cov=lapply(site.list, function(x)     #mixed models#
    {#
        if(is.X.null) {#
            formula = as.formula(paste(x,"~(1|chip)+Z", sep=""))#
        } else {#
            formula = as.formula(paste(x,"~(1|chip)+Z + X1 + X2", sep=""))#
        }#
        model =try (do.call("lmer", args = list(formula,data=beta1,na.action="na.exclude")))#
        if (inherits(model, "try-error")) {#
            c("NA")#
        } else {#
            v_a=as.data.frame(VarCorr(model))[1,4]        #var of batch eff#
            v_e=as.data.frame(VarCorr(model))[2,4]      #var of error#
            Cov=matrix(0,n,n)                        #list for block diagonal matrix#
            tmp.D.index1 = 1#
            for ( i in 1:length(C))#
            {#
                tmp.D.index2 = tmp.D.index1 + C[i]-1#
            Cov[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]=solve(matrix(rep(v_a,C[i]*C[i]),C[i],C[i]) + diag(v_e,C[i]))# matrix(rep(v_a,C[i]*C[i]),C[i],C[i]) + diag(v_e,C[i]) ##
                tmp.D.index1 = tmp.D.index2 + 1#
            }#
            return(Cov)#
        }#
    }#
    ) ## calcluate the Sigma_k in the LMM, we will use it in the future. The main difference between SKAT and this method#
    names(mix_eff_cov) = site.list#
    if(is.X.null) {#
        tilde.x = cbind(rep(1,n))#
    } else {#
        tilde.x = cbind(rep(1,n), beta1$X1,beta1$X2)#
    }
sigma = matrix(c(0.1,0.05,0.05,0.2),2,2)
sigma
beta1[1:2,] = mvrnorm(n = 200, rep(0,2), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE))
beta1[1:2,] = mvrnorm(n = 200, rep(0,2), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)
mvrnorm(n = 200, rep(0,2), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)
beta1[1:2,] = mvrnorm(n = 200, rep(0,2), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)
class(mvrnorm(n = 200, rep(0,2), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE))
dim(beta1)
beta1[,1:2] = mvrnorm(n = 200, rep(0,2), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)
tmp.res = matrix(NA,10000,2)#
    sigma = matrix(c(0.1,0.05,0.05,0.2),2,2)#
    for (i in 1:10000) {#
        beta1[,1:2] = mvrnorm(n = 200, rep(0,2), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
    score_stat=lapply(site.list, function(x)     #score stats for m sites#
    {#
        hat.beta = (solve(t(tilde.x) %*% mix_eff_cov[[x]] %*% tilde.x)) %*% (t(tilde.x) %*% mix_eff_cov[[x]] %*%as.matrix(beta1[x]))#
        s=t(beta1[x]) %*% mix_eff_cov[[x]] %*% beta1$Z - t(hat.beta) %*% t(tilde.x) %*% mix_eff_cov[[x]] %*% beta1$Z#
    }#
    )#
    tmp.res[i,] = as.vector(unlist(score_stat))#
    }
cov(tmp.res)
if(sum(is.na(U)) >0) {#
        indicator =  !is.na(U)#
        site.list = site.list[indicator]#
        mix_eff_cov = mix_eff_cov[indicator]#
        U = U[indicator]#
        fianl.indicator = 9#
    } else {#
        fianl.indicator = 1#
    }# delete the NA CpG sits#
    m=length(site.list)#
    T=t(U)%*%U                                    #SumSqU test statistic#
    CovS=matrix(0,m,m)                        #cov of the m score stats#
    tmp =list()#
    sigma = list()#
    tmp.x = list()#
    for(i in 1:m) {#
        tmp[[i]] =  beta1$Z %*% mix_eff_cov[[i]] %*% tilde.x %*% (solve(t(tilde.x) %*% mix_eff_cov[[i]] %*% tilde.x))#
        sigma[[i]] = beta1$Z %*% mix_eff_cov[[i]]#
        tmp.x[[i]] = t(tilde.x) %*% mix_eff_cov[[i]]#
    }#
    for ( i in 1:m)#
    {#
        for ( j in 1:i)#
        {#
            CovS[i,j]=CovS[j,i]= cov(beta1[site.list[i]],beta1[site.list[j]]) * ( sigma[[i]] %*% t(sigma[[j]]) - tmp[[i]] %*% tmp.x[[i]] %*% t(sigma[[j]]) - tmp[[j]] %*% tmp.x[[j]] %*% t(sigma[[i]]) +  tmp[[i]] %*% tmp.x[[i]] %*% t(tmp.x[[j]]) %*% t(tmp[[j]]) )#
        }#
    }
cov(tmp.res)
CovS
CovS/cov(tmp.res)
##################################
### Simulation 1              ####
##################################
#
library(MASS)#
library("truncnorm")#
library(lme4)#
library(lmerTest)#
library(permute)#
###############################################################################
### Get the core index, we will use this index as the lambda2 index      ######
###############################################################################
args=(commandArgs(TRUE))#
job = as.numeric(gsub("\\job=", "", args))#
data.index = job#
res = matrix(NA,1000,2)
chip.size = 10#
#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 2# number of CpG sites in the gene#
#
informative.num = 1#
beta = c(rep(0,informative.num),rep(0,n.y-informative.num))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.6),(tmp.norm.ind<0.3)* rnorm(n,0.2,0.1)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.8,0.1))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
#
#Y <- t(X %*% matrix(rep(c(0.05,0.1),times = n.y),2,n.y) ) + as.matrix(beta) %*% t(as.matrix(Z)) + error#
Y <- as.matrix(beta) %*% t(as.matrix(Z)) + error#
#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")#
rownames(Y) = paste("Y",c(1:n.y),sep="")
beta <- Y#
    beta = t(beta)#
    is.X.null = is.null(X)#
    if( is.X.null) {#
        beta1 =as.data.frame(beta)#
        beta1$chip = rep(1:length(C),each = C[1])#
        beta1$Z = Z#
    } else {#
        X = as.data.frame(X)#
        X$chip = rep(1:length(C),each = C[1])#
        X$Z = Z#
        beta1 = as.data.frame(cbind(beta,X))#
    }#
    site.list = colnames(beta)#
    n = dim(Y)[2]#
    mix_eff_p=lapply(site.list, function(x)     #mixed models#
    {#
        if(is.X.null) {#
            formula = as.formula(paste(x,"~(1|chip)+Z", sep=""))#
            model =try (do.call("lmer", args = list(formula,data=beta1,na.action="na.exclude")))#
            res = anova(model)[1,6]#
        } else {#
            formula = as.formula(paste(x,"~(1|chip)+Z + X1 + X2", sep=""))#
            model =try (do.call("lmer", args = list(formula,data=beta1,na.action="na.exclude")))#
            res = anova(model)[1,6]#
        }#
        res#
    }#
    ) ## calcluate the Sigma_k in the LMM, we will use it in the future. The main difference between SKAT and this method#
    pvalue=as.vector(unlist(mix_eff_p))#
    minp  = min(pvalue)#
    ## permute y#
    ###
    beta2 = beta1
n.perm = 1000
n.perm = 100
beta2 = beta1#
    minp.dist = sapply (1:n.perm, function(i) {#
        for(k in 1:dim(Y)[1]) {#
            tmp = beta1[,k]#
            plots <- Plots(strata = gl(length(C), C[1]))#
            CTRL <- how(plots = plots, within = Within(type = "free"))#
            beta2[,k] = tmp[shuffle(n, CTRL)]#
        }#
        mix_eff_p = lapply(site.list, function(x)     #mixed models#
        {#
            if(is.X.null) {#
                formula = as.formula(paste(x,"~(1|chip)+Z", sep=""))#
                model =try (do.call("lmer", args = list(formula,data=beta2,na.action="na.exclude")))#
                return(anova(model)[1,6])#
            } else {#
                formula = as.formula(paste(x,"~(1|chip)+Z + X1 + X2", sep=""))#
                model =try (do.call("lmer", args = list(formula,data=beta2,na.action="na.exclude")))#
                res = anova(model)[1,6]#
            }#
            res#
        }#
        ) ## calcluate the Sigma_k in the LMM, we will use it in the future. The main difference between SKAT and this method#
        pvalue=as.vector(unlist(mix_eff_p))#
        min(pvalue)#
    })
for(k in 1:dim(Y)[1]) {#
            tmp = beta1[,k]#
            plots <- Plots(strata = gl(length(C), C[1]))#
            CTRL <- how(plots = plots, within = Within(type = "free"))#
            beta2[,k] = tmp[shuffle(n, CTRL)]#
        }
shuffle(n, CTRL)
shuffle(n, CTRL)[11]
shuffle(n, CTRL)[21]
shuffle(n, CTRL)[31]
shuffle(n, CTRL)[41]
n.perm = 1000
minp.dist = sapply (1:n.perm, function(i) {#
        for(k in 1:dim(Y)[1]) {#
            tmp = beta1[,k]#
            plots <- Plots(strata = gl(length(C), C[1]))#
            CTRL <- how(plots = plots, within = Within(type = "free"))#
            beta2[,k] = tmp[shuffle(n, CTRL)]#
        }#
        mix_eff_p = lapply(site.list, function(x)     #mixed models#
        {#
            if(is.X.null) {#
                formula = as.formula(paste(x,"~(1|chip)+Z", sep=""))#
                model =try (do.call("lmer", args = list(formula,data=beta2,na.action="na.exclude")))#
                return(anova(model)[1,6])#
            } else {#
                formula = as.formula(paste(x,"~(1|chip)+Z + X1 + X2", sep=""))#
                model =try (do.call("lmer", args = list(formula,data=beta2,na.action="na.exclude")))#
                res = anova(model)[1,6]#
            }#
            res#
        }#
        ) ## calcluate the Sigma_k in the LMM, we will use it in the future. The main difference between SKAT and this method#
        pvalue=as.vector(unlist(mix_eff_p))#
        min(pvalue)#
    })
minp.dist
out = (sum(minp <minp.dist)+1)/n.perm
out
minp.dist = sapply (1:n.perm, function(i) {#
        for(k in 1:dim(Y)[1]) {#
            tmp = beta1[,k]#
            plots <- Plots(strata = gl(length(C), C[1]))#
            CTRL <- how(plots = plots, within = Within(type = "free"))#
            beta2[,k] = tmp[shuffle(n, CTRL)]#
        }#
        mix_eff_p = lapply(site.list, function(x)     #mixed models#
        {#
            if(is.X.null) {#
                formula = as.formula(paste(x,"~(1|chip)+Z", sep=""))#
                model =try (do.call("lmer", args = list(formula,data=beta2,na.action="na.exclude")))#
                if (inherits(model, "try-error")) {#
                    c("NA")#
                } else {#
                    return(anova(model)[1,6])#
                }#
            } else {#
                formula = as.formula(paste(x,"~(1|chip)+Z + X1 + X2", sep=""))#
                model =try (do.call("lmer", args = list(formula,data=beta2,na.action="na.exclude")))#
                if (inherits(model, "try-error")) {#
                    c("NA")#
                } else {#
                    return(anova(model)[1,6])#
                }#
            }#
        }#
        ) ## calcluate the Sigma_k in the LMM, we will use it in the future. The main difference between SKAT and this method#
        min(as.vector(unlist(mix_eff_p)),na.rm = TRUE)#
    })
##################################
#
library(MASS)#
library("truncnorm")#
library(lme4)#
library(lmerTest)#
library(permute)#
###############################################################################
### Get the core index, we will use this index as the lambda2 index      ######
###############################################################################
args=(commandArgs(TRUE))#
job = as.numeric(gsub("\\job=", "", args))#
data.index = job#
res = matrix(NA,1000,2)#
chip.size = 10#
#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 2# number of CpG sites in the gene#
#
informative.num = 1#
beta = c(rep(0,informative.num),rep(0,n.y-informative.num))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.6),(tmp.norm.ind<0.3)* rnorm(n,0.2,0.1)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.8,0.1))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
#
Y <- t(X %*% matrix(rep(c(0.05,0.2),times = n.y),2,n.y) ) + as.matrix(beta) %*% t(as.matrix(Z)) + error#
#Y <- as.matrix(beta) %*% t(as.matrix(Z)) + error
minp.dist
source("SumSqU.R")#
source("SumSqU2.R")#
source("minP.R")#
###############################################################################
### Get the core index, we will use this index as the lambda2 index      ######
###############################################################################
args=(commandArgs(TRUE))#
job = as.numeric(gsub("\\job=", "", args))#
data.index = job#
#
chip.size = 10#
# Z is generated from Bin(p)#
n = 200 # sample size#
Z = rbinom(n,1,0.4)#
n.y = 20# number of CpG sites in the gene#
#
informative.num = 1#
beta = c(rep(0,informative.num),rep(0,n.y-informative.num))#
C = rep(chip.size,n/chip.size)#
#
#generate Y; we assume each gene has 20 CpG sites. Note that this is the average of the#
#
tmp.norm.ind = runif(n)#
# generate the other covariates#
X = cbind(rbinom(n,1,0.6),(tmp.norm.ind<0.3)* rnorm(n,0.2,0.1)+ (tmp.norm.ind>=0.3) * rnorm(n, 0.8,0.1))#
# generate the sigma matrix: random design matrix + random error matrix#
sigma = matrix(0,n,n)#
n.len = n/chip.size#
sigma.r = 0.0005#
sigma.e = 0.0005#
tmp.D.index1 = 1#
for (i in 1:n.len) {#
    tmp.D.index2 = tmp.D.index1 + C[i]-1#
    sigma[tmp.D.index1:tmp.D.index2,tmp.D.index1:tmp.D.index2]= matrix(rep(sigma.e,C[i]*C[i]),C[i],C[i]) + diag(x = sigma.e,C[i],C[i])#
    tmp.D.index1 = tmp.D.index2 + 1#
}#
#
error = mvrnorm(n = n.y, rep(0,n), sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)#
#
Y <- t(X %*% matrix(rep(c(0.05,0.2),times = n.y),2,n.y) ) + as.matrix(beta) %*% t(as.matrix(Z)) + error#
#Y <- as.matrix(beta) %*% t(as.matrix(Z)) + error#
#
#t(X%*% matrix(rep(c(0.1,0.2),n.y),2,n.y)) +#
colnames(X) = c("X1","X2")#
rownames(Y) = paste("Y",c(1:n.y),sep="")#
#
SumSqU(Y,X,Z,C)
10*20
3*60+15
500*3*1.5
500*3*1.5*4
40*3
40*3*2
240/60
?drop
#setwd("/Users/chong/Google Drive/homework/research-undergoing/MicrobiomeTest/simulation/sim4")#
setwd("/panfs/roc/groups/1/panwei/wuxx0845/MicrobiomeTest/simulation/sim4")#
library(aSPU)#
library("GUniFrac")#
library("dirmult")#
#library("DirichletReg")#
library("adephylo")#
library(reshape)#
library(cluster)#
library(BiasedUrn)#
library(CompQuadForm)#
library(iSKAT)#
source("generateSNP.R")#
source("GxE-scoretest-logistic-snpset-v22.R")#
source("GxE-scoretest-snpset-v12.R")#
source("iSKAT-Linear-v4.R")#
source("iSKAT-Logistic-v3.R")#
source("Main_GESAT.R")#
source("Main_iSKAT.R")#
#
source("iSPU.R")#
source("iSPU.logistic.R")#
source("iSPU-support.R")#
#
###############################################################################
### Get the core index, we will use this index as the lambda2 index      ######
###############################################################################
args=(commandArgs(TRUE))#
job = as.numeric(gsub("\\job=", "", args))#
data.index = job#
#
################################################################################
### Generate the data set  and set the parameters                         ######
################################################################################
data.index = job#
set.seed(data.index)#
data(throat.otu.tab)#
data(throat.tree)#
data(throat.meta)#
#
#######################################################
## The parameters we need specify beforehand       ####
#######################################################
nSam = 500  #the number of samples#
s=2       #the clusters we used as the environment factor#
nSNP0 = 10 # the number of related SNP#
nSNP = 5 # the number of unrelated SNP#
########################################################
tree <- throat.tree#
tree.dist <- cophenetic(tree)#
obj <- pam(as.dist(tree.dist), 20,diss =TRUE)#
clustering <- obj$clustering#
#
tmp.res = matrix(NA,20,1)#
for(i in 1:20) {#
    tmp.res[i,] = sum(clustering == i)#
}#
#
otu.ids <- tree$tip.label#
#
load("DirMultOutput.RData")#
p.est = dd$pi#
names(p.est) <- names(dd$pi)#
theta <- dd$theta#
gplus <- (1 - theta) / theta#
p.est <- p.est[otu.ids]#
g.est <- p.est * gplus#
p.clus <- sort(tapply(p.est, clustering, sum), decr=T)#
scale2 = function(x)as.numeric(scale(x))#
#
comm <- matrix(0, nSam, length(g.est))#
rownames(comm) <- 1:nrow(comm)#
colnames(comm) <- names(g.est)#
comm.p <- comm#
nSeq <- rnbinom(nSam, mu = 1000, size = 25)#
for (i in 1:nSam) {#
    comm.p[i, ] <- rdirichlet(1, g.est)[1, ]#
    comm[i, ] <- rmultinom(1, nSeq[i], prob=comm.p[i, ])[, 1]#
}#
#
otu.ids <- names(which(clustering == s))#
#
OTU = comm[, otu.ids]#
#
##########################################
## generate SNP data set              ####
##########################################
#
SNP  = simAR1RareSNP(nSam,nSNP0 = nSNP0,nSNP = nSNP)#
#
#########
y  = SNP[,1:nSNP0] %*% runif(nSNP0,1,1.5)+ scale2(rowSums(OTU)) * 5 + rnorm(nSam,0,0.5)#
xb = SNP[,1:nSNP0] %*% runif(nSNP0,1,1.5)+ scale2(rowSums(OTU)) * 5#
#
y <-  rbinom(nSam, 1, prob=1/(1+exp(-xb)))# For this case, we don't consider#
Y = as.matrix(y)
25*24
22*24
21*24
setwd("/panfs/roc/groups/1/panwei/wuxx0845/swak/sim1/")#
library(xtable)#
plot.res = matrix(NA,7,6)#
read.file <- function (file.name) {#
    file <- try(read.table(file.name))#
    if (class(file) == "try-error") {#
        #cat("Caught an error during fread, trying read.table.\n")#
        file <- NULL#
    }#
    file#
}#
### OR = 1 , SNP = 200#
final.res = matrix(0,9,10)#
out.i = 1#
for (i in 1:2000)#
{#
index = i#
file.name = paste("final0Res",index,".txt",sep="")#
#
res.temp <-read.file(file.name)#
if(!is.null(res.temp)) {#
    res.temp =  as.matrix(res.temp)#
    final.res = final.res + matrix(as.numeric(res.temp<0.05),9,10)#
    out.i = out.i + 1#
}#
#
}#
#
final.res = final.res/out.i#
final.res
setwd("/Users/chong/Google Drive/SWAK/simulation/swak-10-27/sim2")#
library(aSPU)#
library("GUniFrac")#
library("dirmult")#
#library("DirichletReg")#
library("adephylo")#
library(reshape)#
library(cluster)#
library(BiasedUrn)#
library(CompQuadForm)#
library(MiRKAT)#
source("GUniFrac.R")#
source("MiSPU.R")#
source("swak.R")#
library(RcppArmadillo)#
library(Rcpp)#
sourceCpp("swak.cpp")#
###############################################################################
### Get the core index, we will use this index as the lambda2 index      ######
###############################################################################
args=(commandArgs(TRUE))#
job = as.numeric(gsub("\\job=", "", args))#
data.index = job#
#
################################################################################
### Generate the data set  and set the parameters                         ######
################################################################################
data.index = job#
set.seed(data.index)#
data(throat.otu.tab)#
data(throat.tree)#
data(throat.meta)#
#
nSam = 100#
s=12#
tree <- throat.tree#
tree.dist <- cophenetic(tree)#
obj <- pam(as.dist(tree.dist), 20,diss =TRUE)#
clustering <- obj$clustering#
otu.ids <- tree$tip.label#
load("DirMultOutput.RData")#
p.est = dd$pi#
names(p.est) <- names(dd$pi)#
theta <- dd$theta#
gplus <- (1 - theta) / theta#
p.est <- p.est[otu.ids]#
g.est <- p.est * gplus#
p.clus <- sort(tapply(p.est, clustering, sum), decr=T)#
scale2 = function(x)as.numeric(scale(x))#
comm <- matrix(0, nSam, length(g.est))#
rownames(comm) <- 1:nrow(comm)#
colnames(comm) <- names(g.est)#
# comm.p hold the underlying proportions#
comm.p <- comm#
nSeq <- rnbinom(nSam, mu = 1000, size = 25)#
for (i in 1:nSam) {#
    comm.p[i, ] <- rdirichlet(1, g.est)[1, ]#
    comm[i, ] <- rmultinom(1, nSeq[i], prob=comm.p[i, ])[, 1]#
}#
#
otu.ids <- names(which(clustering == s))#
# y <- scale(apply(comm.p[, otu.ids], 1, sum))[, 1] * b * f + rnorm(nSam,mean =0, sd = sqrt(1.5)) # var = 1.5#
#
# No additional covariates in this case.#
OTU = comm[, otu.ids]#
#
X   = cbind(runif(nSam)<0.5, rnorm(nSam) + scale2(rowSums(OTU))*0)#
xb  = scale2(X[,1] + X[,2]) * 0.5 + scale2(rowSums(OTU)) * 0#
pro=1/(1+exp(-xb))#
y <-  rbinom(nSam, 1, prob=1/(1+exp(-xb)))# For this case, we don't consider
Y = y
X = comm
cov = NULL
tree = throat.tree
pow=c(0.5,1,1.5,2)
B = 1000
out_type = "D"
n <- length(Y)#
    if (is.null(X) && length(X)>0) X=as.matrix(X, ncol=1)#
    k <- ncol(X)#
    if (class(X)!= "matrix") stop("X is not a matrix")#
    if (nrow(X)!=n) stop("Dimensions of y and X do not match")#
    m = ncol(X)#
    if (out_type == "D") {#
        family = "binomial"#
        if (is.null(cov)) {#
            mu    = rep(mean(Y), n)#
            residual   = Y - mu#
        } else {#
            mod = glm(Y~cov, family = family)#
            mu  = mod$fitted.values#
            residual = Y - mu#
        }#
    } else {#
        if (is.null(cov)) {#
            mu    = rep(mean(Y), n)#
            residual   = Y - mu#
        } else {#
            mod  = lm(Y~cov)#
            mu  = mod$fitted.values#
            residual = Y - mu#
        }#
    }#
    ##observed statistics#
    out.i = 1#
    GuniF.cum = GUniFrac_cum(X,tree)#
    cum = GuniF.cum$cum#
    br.len = GuniF.cum$br.len#
    br.len = as.matrix(br.len)#
    U = residual %*% t(cum)#
    U = abs(U)#
    score.weight = U^0#
    GUniF = GUniFracCpp(cum,br.len,score.weight)#
    tmp = GUniFrac(X, tree, alpha = c(0))$unifracs#
    duw = tmp[, , "d_UW"]#
    d0 = GUniF$d0#
    dw = GUniF$d1  # Weighted UniFrac#
    d5 = GUniF$d5    # GUniFrac with alpha 0.5#
    dbc = BCdist(cum,t(score.weight))#
#
    ## transform the distance matrix to the kernel#
    duw = D2K(duw)#
    d0 = D2K(d0)#
    dw = D2K(dw)#
    d5 = D2K(d5)#
    dbc = D2K(dbc)#
#
    ks = list(dbc,duw,d0,d5,dw)#
    output = matrix(NA,9,10)
cum2 = cum *matrix(rep(br.len,each = dim(cum)[2]),nrow = dim(cum)[1],ncol = dim(cum)[2],byrow = TRUE)#
        cum3 = tmp.cum *matrix(rep(br.len,each = dim(cum)[2]),nrow = dim(cum)[1],ncol = dim(cum)[2],byrow = TRUE)#
#
        start.time = proc.time()[3]#
        aSPU.res <- aSPU(Y, t(cum2), cov = cov, resample = "perm",model = "binomial", pow = c(2:8, Inf), n.perm = B)#
         aSPU.res <- aSPU(Y, t(cum3), cov = cov, resample = "perm",model = "binomial", pow = c(2:8, Inf), n.perm = B)#
        proc.time()[3]- start.time#
        start.time = proc.time()[3]#
        MiSPU.res <- MiSPUR(Y,t(cum2),t(cum3), cov = cov, model = "binomial",pow = c(2:8, Inf), n.perm = B)#
        proc.time()[3]- start.time
cum
br.len
cum2 = cum *matrix(rep(br.len,each = dim(cum)[2]),nrow = dim(cum)[1],ncol = dim(cum)[2],byrow = TRUE)#
        cum3 = tmp.cum *matrix(rep(br.len,each = dim(cum)[2]),nrow = dim(cum)[1],ncol = dim(cum)[2],byrow = TRUE)
cum2 = cum *matrix(rep(br.len,each = dim(cum)[2]),nrow = dim(cum)[1],ncol = dim(cum)[2],byrow = TRUE)#
        tmp.cum = cum#
        tmp.cum[tmp.cum != 0] = 1#
        cum3 = tmp.cum *matrix(rep(br.len,each = dim(cum)[2]),nrow = dim(cum)[1],ncol = dim(cum)[2],byrow = TRUE)
start.time = proc.time()[3]#
        aSPU.res <- aSPU(Y, t(cum2), cov = cov, resample = "perm",model = "binomial", pow = c(2:8, Inf), n.perm = B)#
         aSPU.res <- aSPU(Y, t(cum3), cov = cov, resample = "perm",model = "binomial", pow = c(2:8, Inf), n.perm = B)#
        proc.time()[3]- start.time#
        start.time = proc.time()[3]#
        MiSPU.res <- MiSPUR(Y,t(cum2),t(cum3), cov = cov, model = "binomial",pow = c(2:8, Inf), n.perm = B)#
        proc.time()[3]- start.time
B = 10000
start.time = proc.time()[3]#
        aSPU.res <- aSPU(Y, t(cum2), cov = cov, resample = "perm",model = "binomial", pow = c(2:8, Inf), n.perm = B)#
         aSPU.res <- aSPU(Y, t(cum3), cov = cov, resample = "perm",model = "binomial", pow = c(2:8, Inf), n.perm = B)#
        proc.time()[3]- start.time#
        start.time = proc.time()[3]#
        MiSPU.res <- MiSPUR(Y,t(cum2),t(cum3), cov = cov, model = "binomial",pow = c(2:8, Inf), n.perm = B)#
        proc.time()[3]- start.time
B
B = 20000
start.time = proc.time()[3]#
        aSPU.res <- aSPU(Y, t(cum2), cov = cov, resample = "perm",model = "binomial", pow = c(2:8, Inf), n.perm = B)#
         aSPU.res <- aSPU(Y, t(cum3), cov = cov, resample = "perm",model = "binomial", pow = c(2:8, Inf), n.perm = B)#
        proc.time()[3]- start.time#
        start.time = proc.time()[3]#
        MiSPU.res <- MiSPUR(Y,t(cum2),t(cum3), cov = cov, model = "binomial",pow = c(2:8, Inf), n.perm = B)#
        proc.time()[3]- start.time
B = 50000
start.time = proc.time()[3]#
        aSPU.res <- aSPU(Y, t(cum2), cov = cov, resample = "perm",model = "binomial", pow = c(2:8, Inf), n.perm = B)#
         aSPU.res <- aSPU(Y, t(cum3), cov = cov, resample = "perm",model = "binomial", pow = c(2:8, Inf), n.perm = B)#
        proc.time()[3]- start.time#
        start.time = proc.time()[3]#
        MiSPU.res <- MiSPUR(Y,t(cum2),t(cum3), cov = cov, model = "binomial",pow = c(2:8, Inf), n.perm = B)#
        proc.time()[3]- start.time
MiSPU.res
aSPU.res
